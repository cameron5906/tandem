import { TandemIR, IRIntent, IRType, IRTypeRef } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { ITypeMapper } from "../interfaces/ITypeMapper";
import { shorten } from "../utils/naming";
import { groupByModule, moduleToDirectory } from "../utils/modulePath";
import { ImportResolver } from "../utils/importResolver";
import { generateAggregateBarrel } from "../utils/barrelGenerator";

/**
 * Options for TypeDeclarationEmitter.
 */
export interface TypeDeclarationEmitterOptions {
  /** Whether to generate input/output types for intents (default: true) */
  includeIntentTypes?: boolean;
}

/**
 * Emits TypeScript type declarations (type aliases and interfaces) from Tandem IR.
 * Generates per-module type files organized by module path.
 */
export class TypeDeclarationEmitter implements ICodeEmitter {
  private options: Required<TypeDeclarationEmitterOptions>;
  private importResolver: ImportResolver;

  constructor(
    private typeMapper: ITypeMapper,
    options: TypeDeclarationEmitterOptions = {},
    importResolver?: ImportResolver
  ) {
    this.options = {
      includeIntentTypes: options.includeIntentTypes ?? true,
    };
    this.importResolver = importResolver ?? new ImportResolver();
  }

  /**
   * Emit TypeScript type declarations from the IR.
   * Generates per-module files organized by module path.
   */
  emit(ir: TandemIR): GeneratedCode[] {
    // Register all types with the import resolver
    this.importResolver.registerTypes(ir.types);

    const files: GeneratedCode[] = [];

    // Group types and intents by module
    const typesByModule = groupByModule(ir.types);
    const intentsByModule = groupByModule(ir.intents);

    // Get all unique module paths
    const allModules = new Set([
      ...typesByModule.keys(),
      ...intentsByModule.keys(),
    ]);

    // Track exports for aggregate barrel
    const moduleExports = new Map<string, string[]>();

    // Emit types.ts for each module
    for (const modulePath of allModules) {
      const moduleTypes = typesByModule.get(modulePath) ?? new Map();
      const moduleIntents = intentsByModule.get(modulePath) ?? new Map();

      const { content, exports } = this.emitModuleTypes(
        modulePath,
        moduleTypes,
        moduleIntents
      );

      if (content) {
        const dir = moduleToDirectory(modulePath);
        files.push({
          filename: `${dir}/types.ts`,
          content,
        });

        // Track exports for aggregate
        if (exports.length > 0) {
          moduleExports.set(dir, exports);
        }
      }
    }

    // Generate aggregate types.ts that re-exports from all modules
    if (moduleExports.size > 0) {
      files.push({
        filename: "types.ts",
        content: generateAggregateBarrel(moduleExports, true),
      });
    }

    return files;
  }

  /**
   * Emit types.ts content for a single module.
   */
  private emitModuleTypes(
    modulePath: string,
    types: Map<string, IRType>,
    intents: Map<string, IRIntent>
  ): { content: string; exports: string[] } {
    const exports: string[] = [];
    const typeRefs: IRTypeRef[] = [];

    // Collect all external type references
    for (const [, type] of types) {
      if (type.kind === "alias") {
        typeRefs.push(type.target);
      } else {
        for (const field of type.fields) {
          typeRefs.push(field.type);
        }
      }
    }

    for (const [, intent] of intents) {
      for (const field of intent.inputType.fields) {
        typeRefs.push(field.type);
      }
      typeRefs.push(intent.outputType);
    }

    // Generate import statements for external types
    const imports = this.importResolver.resolveAndGenerate(modulePath, typeRefs);

    let content = "// Generated by Tandem - DO NOT EDIT\n\n";

    if (imports) {
      content += imports + "\n";
    }

    // Emit user-defined types
    for (const [fqn, type] of types) {
      const name = shorten(fqn);
      exports.push(name);

      if (type.kind === "alias") {
        const targetType = this.typeMapper.mapType(type.target);
        content += `export type ${name} = ${targetType};\n\n`;
      } else {
        content += `export interface ${name} {\n`;
        for (const field of type.fields) {
          const fieldType = this.typeMapper.mapType(field.type);
          content += `  ${field.name}: ${fieldType};\n`;
        }
        content += `}\n\n`;
      }
    }

    // Emit intent input/output types if enabled
    if (this.options.includeIntentTypes && intents.size > 0) {
      content += "// Intent Input/Output Types\n\n";

      for (const [fqn, intent] of intents) {
        const name = shorten(fqn);
        exports.push(`${name}Input`);
        exports.push(`${name}Output`);

        content += this.emitIntentInputOutput(name, intent);
      }
    }

    return { content, exports };
  }

  /**
   * Emit input and output types for a single intent.
   */
  private emitIntentInputOutput(name: string, intent: IRIntent): string {
    let content = "";

    // Emit input interface
    content += `export interface ${name}Input {\n`;
    for (const field of intent.inputType.fields) {
      const fieldType = this.typeMapper.mapType(field.type);
      content += `  ${field.name}: ${fieldType};\n`;
    }
    content += `}\n\n`;

    // Emit output type alias
    const outputType = this.typeMapper.mapType(intent.outputType);
    content += `export type ${name}Output = ${outputType};\n\n`;

    return content;
  }
}
