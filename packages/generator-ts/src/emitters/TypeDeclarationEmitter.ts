import { TandemIR, IRIntent } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { ITypeMapper } from "../interfaces/ITypeMapper";
import { shorten } from "../utils/naming";

/**
 * Options for TypeDeclarationEmitter.
 */
export interface TypeDeclarationEmitterOptions {
  /** Whether to generate input/output types for intents (default: true) */
  includeIntentTypes?: boolean;
}

/**
 * Emits TypeScript type declarations (type aliases and interfaces) from Tandem IR.
 */
export class TypeDeclarationEmitter implements ICodeEmitter {
  private options: Required<TypeDeclarationEmitterOptions>;

  constructor(
    private typeMapper: ITypeMapper,
    options: TypeDeclarationEmitterOptions = {}
  ) {
    this.options = {
      includeIntentTypes: options.includeIntentTypes ?? true,
    };
  }

  /**
   * Emit TypeScript type declarations from the IR.
   */
  emit(ir: TandemIR): GeneratedCode[] {
    let content = "// Generated by Tandem - DO NOT EDIT\n\n";

    // Emit user-defined types
    content += this.emitUserTypes(ir);

    // Emit intent input/output types
    if (this.options.includeIntentTypes) {
      content += this.emitIntentTypes(ir);
    }

    return [{ filename: "types.ts", content }];
  }

  /**
   * Emit user-defined type declarations.
   */
  private emitUserTypes(ir: TandemIR): string {
    let content = "";

    for (const [fqn, type] of ir.types) {
      const name = shorten(fqn);

      if (type.kind === "alias") {
        const targetType = this.typeMapper.mapType(type.target);
        content += `export type ${name} = ${targetType};\n`;
      } else {
        content += `export interface ${name} {\n`;
        for (const field of type.fields) {
          const fieldType = this.typeMapper.mapType(field.type);
          content += `  ${field.name}: ${fieldType};\n`;
        }
        content += `}\n`;
      }
      content += "\n";
    }

    return content;
  }

  /**
   * Emit input and output types for all intents.
   */
  private emitIntentTypes(ir: TandemIR): string {
    if (ir.intents.size === 0) {
      return "";
    }

    let content = "// Intent Input/Output Types\n\n";

    for (const [fqn, intent] of ir.intents) {
      content += this.emitIntentInputOutput(fqn, intent);
    }

    return content;
  }

  /**
   * Emit input and output types for a single intent.
   */
  private emitIntentInputOutput(fqn: string, intent: IRIntent): string {
    const name = shorten(fqn);
    let content = "";

    // Emit input interface
    content += `export interface ${name}Input {\n`;
    for (const field of intent.inputType.fields) {
      const fieldType = this.typeMapper.mapType(field.type);
      content += `  ${field.name}: ${fieldType};\n`;
    }
    content += `}\n\n`;

    // Emit output type alias
    const outputType = this.typeMapper.mapType(intent.outputType);
    content += `export type ${name}Output = ${outputType};\n\n`;

    return content;
  }
}
