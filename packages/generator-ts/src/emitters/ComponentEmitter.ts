import { TandemIR, IRComponent, IRTypeRef } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { ITypeMapper } from "../interfaces/ITypeMapper";
import { shorten, toHookName } from "../utils/naming";

/**
 * Emits React component files from Tandem IR components.
 * Generates semantic UI components based on element type.
 */
export class ComponentEmitter implements ICodeEmitter {
  constructor(private typeMapper: ITypeMapper) {}

  emit(ir: TandemIR): GeneratedCode[] {
    const files: GeneratedCode[] = [];

    for (const [fqn, component] of ir.components) {
      const file = this.emitComponent(fqn, component, ir);
      files.push(file);
    }

    // Generate index file if there are components
    if (ir.components.size > 0) {
      files.push(this.emitIndex(ir));
    }

    return files;
  }

  private emitComponent(
    fqn: string,
    component: IRComponent,
    ir: TandemIR
  ): GeneratedCode {
    const name = shorten(fqn);

    switch (component.element) {
      case "form":
        return this.emitFormComponent(name, component, ir);
      case "card":
        return this.emitCardComponent(name, component, ir);
      case "list":
        return this.emitListComponent(name, component, ir);
      case "table":
        return this.emitTableComponent(name, component, ir);
      case "modal":
        return this.emitModalComponent(name, component, ir);
      case "detail":
        return this.emitDetailComponent(name, component, ir);
      default:
        return this.emitGenericComponent(name, component);
    }
  }

  private emitFormComponent(
    name: string,
    component: IRComponent,
    ir: TandemIR
  ): GeneratedCode {
    const hookName = component.binds ? toHookName(component.binds) : "";
    const inputType = component.binds
      ? `${shorten(component.binds)}Input`
      : "unknown";

    let content = `// Generated by Tandem - DO NOT EDIT
import { useState, FormEvent } from "react";
${component.binds ? `import { ${hookName} } from "../hooks";\n` : ""}import { ${inputType} } from "../types";

interface ${name}Props {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
  initialData?: Partial<${inputType}>;
}

/**
 * ${component.spec || `Form component bound to ${component.binds}`}
 */
export function ${name}({ onSuccess, onError, initialData }: ${name}Props) {
  const [formData, setFormData] = useState<Partial<${inputType}>>(initialData || {});
  ${
    component.binds
      ? `const mutation = ${hookName}({
    onSuccess,
    onError,
  });`
      : ""
  }

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    ${component.binds ? `mutation.mutate(formData as ${inputType});` : "// TODO: Handle form submission"}
  };

  const handleChange = (field: keyof ${inputType}, value: unknown) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <form onSubmit={handleSubmit} className="tandem-form">
      {/* TODO: AI should generate form fields based on ${inputType} schema */}
      <div className="tandem-form-fields">
        {Object.keys(formData).map(key => (
          <div key={key} className="tandem-form-field">
            <label>{key}</label>
            <input
              type="text"
              value={String(formData[key as keyof ${inputType}] ?? "")}
              onChange={e => handleChange(key as keyof ${inputType}, e.target.value)}
            />
          </div>
        ))}
      </div>
      <button type="submit" disabled={${component.binds ? "mutation.isPending" : "false"}}>
        {${component.binds ? 'mutation.isPending ? "Submitting..." : "Submit"' : '"Submit"'}}
      </button>
    </form>
  );
}
`;
    return { filename: `components/${name}.tsx`, content };
  }

  private emitCardComponent(
    name: string,
    component: IRComponent,
    ir: TandemIR
  ): GeneratedCode {
    const displayType = component.displays
      ? this.typeMapper.mapType(component.displays)
      : "unknown";
    const typeShortName = this.getTypeShortName(component.displays);

    const actionHooks =
      component.actions && component.actions.length > 0
        ? component.actions
            .map((a) => `import { ${toHookName(a)} } from "../hooks";`)
            .join("\n")
        : "";

    let content = `// Generated by Tandem - DO NOT EDIT
${actionHooks ? actionHooks + "\n" : ""}import { ${typeShortName} } from "../types";

interface ${name}Props {
  data: ${displayType};
  onAction?: (action: string, data: ${displayType}) => void;
}

/**
 * ${component.spec || `Card displaying ${typeShortName}`}
 */
export function ${name}({ data, onAction }: ${name}Props) {
  return (
    <div className="tandem-card">
      <div className="tandem-card-content">
        {/* TODO: AI should render fields from ${typeShortName} */}
        <pre>{JSON.stringify(data, null, 2)}</pre>
      </div>
      ${this.generateActionButtons(component.actions || [], "data")}
    </div>
  );
}
`;
    return { filename: `components/${name}.tsx`, content };
  }

  private emitListComponent(
    name: string,
    component: IRComponent,
    ir: TandemIR
  ): GeneratedCode {
    const displayType = component.displays
      ? this.typeMapper.mapType(component.displays)
      : "unknown[]";
    const itemComponent = component.itemComponent
      ? shorten(component.itemComponent)
      : null;

    // Extract the inner type from List<T>
    const innerType = this.extractListInnerType(component.displays);

    let content = `// Generated by Tandem - DO NOT EDIT
${itemComponent ? `import { ${itemComponent} } from "./${itemComponent}";\n` : ""}
interface ${name}Props {
  data: ${displayType};
  isLoading?: boolean;
  onAction?: (action: string, item: ${innerType}) => void;
}

/**
 * ${component.spec || `List component`}
 */
export function ${name}({ data, isLoading, onAction }: ${name}Props) {
  if (isLoading) {
    return <div className="tandem-loading">Loading...</div>;
  }

  if (!data || data.length === 0) {
    return <div className="tandem-empty">${component.emptyState || "No items found"}</div>;
  }

  return (
    <div className="tandem-list">
      {data.map((item, index) => (
        ${
          itemComponent
            ? `<${itemComponent} key={index} data={item} onAction={(action) => onAction?.(action, item)} />`
            : `<div key={index} className="tandem-list-item">{JSON.stringify(item)}</div>`
        }
      ))}
    </div>
  );
}
`;
    return { filename: `components/${name}.tsx`, content };
  }

  private emitTableComponent(
    name: string,
    component: IRComponent,
    ir: TandemIR
  ): GeneratedCode {
    const displayType = component.displays
      ? this.typeMapper.mapType(component.displays)
      : "unknown[]";
    const innerType = this.extractListInnerType(component.displays);

    let content = `// Generated by Tandem - DO NOT EDIT

interface ${name}Props {
  data: ${displayType};
  isLoading?: boolean;
  onAction?: (action: string, item: ${innerType}) => void;
}

/**
 * ${component.spec || `Table component`}
 */
export function ${name}({ data, isLoading, onAction }: ${name}Props) {
  if (isLoading) {
    return <div className="tandem-loading">Loading...</div>;
  }

  if (!data || data.length === 0) {
    return <div className="tandem-empty">${component.emptyState || "No items found"}</div>;
  }

  // Extract column headers from first item
  const columns = data.length > 0 ? Object.keys(data[0] as object) : [];

  return (
    <table className="tandem-table">
      <thead>
        <tr>
          {columns.map(col => (
            <th key={col}>{col}</th>
          ))}
          ${(component.actions?.length || 0) > 0 ? "<th>Actions</th>" : ""}
        </tr>
      </thead>
      <tbody>
        {data.map((item, index) => (
          <tr key={index}>
            {columns.map(col => (
              <td key={col}>{String((item as Record<string, unknown>)[col])}</td>
            ))}
            ${
              (component.actions?.length || 0) > 0
                ? `<td className="tandem-actions">
              ${(component.actions || [])
                .map(
                  (a) =>
                    `<button onClick={() => onAction?.("${shorten(a)}", item)}>${shorten(a)}</button>`
                )
                .join("\n              ")}
            </td>`
                : ""
            }
          </tr>
        ))}
      </tbody>
    </table>
  );
}
`;
    return { filename: `components/${name}.tsx`, content };
  }

  private emitModalComponent(
    name: string,
    component: IRComponent,
    ir: TandemIR
  ): GeneratedCode {
    const hookName = component.binds ? toHookName(component.binds) : "";
    const displayType = component.displays
      ? this.typeMapper.mapType(component.displays)
      : "unknown";

    let content = `// Generated by Tandem - DO NOT EDIT
import { useEffect } from "react";
${component.binds ? `import { ${hookName} } from "../hooks";\n` : ""}
interface ${name}Props {
  isOpen: boolean;
  onClose: () => void;
  ${component.displays ? `initialData?: ${displayType};` : ""}
  onSuccess?: () => void;
}

/**
 * ${component.spec || `Modal component`}
 */
export function ${name}({ isOpen, onClose${component.displays ? ", initialData" : ""}, onSuccess }: ${name}Props) {
  ${
    component.binds
      ? `const mutation = ${hookName}({
    onSuccess: () => {
      onSuccess?.();
      onClose();
    },
  });`
      : ""
  }

  // Close on Escape key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape") onClose();
    };
    if (isOpen) {
      document.addEventListener("keydown", handleEscape);
    }
    return () => document.removeEventListener("keydown", handleEscape);
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div className="tandem-modal-overlay" onClick={onClose}>
      <div className="tandem-modal" onClick={e => e.stopPropagation()}>
        <button className="tandem-modal-close" onClick={onClose}>
          &times;
        </button>
        <div className="tandem-modal-content">
          {/* TODO: AI should generate modal content */}
          ${component.displays ? "<pre>{JSON.stringify(initialData, null, 2)}</pre>" : ""}
        </div>
      </div>
    </div>
  );
}
`;
    return { filename: `components/${name}.tsx`, content };
  }

  private emitDetailComponent(
    name: string,
    component: IRComponent,
    ir: TandemIR
  ): GeneratedCode {
    const displayType = component.displays
      ? this.typeMapper.mapType(component.displays)
      : "unknown";
    const typeShortName = this.getTypeShortName(component.displays);

    const actionHooks =
      component.actions && component.actions.length > 0
        ? component.actions
            .map((a) => `import { ${toHookName(a)} } from "../hooks";`)
            .join("\n")
        : "";

    let content = `// Generated by Tandem - DO NOT EDIT
${actionHooks ? actionHooks + "\n" : ""}import { ${typeShortName} } from "../types";

interface ${name}Props {
  data: ${displayType};
  isLoading?: boolean;
  onAction?: (action: string) => void;
}

/**
 * ${component.spec || `Detail view for ${typeShortName}`}
 */
export function ${name}({ data, isLoading, onAction }: ${name}Props) {
  if (isLoading) {
    return <div className="tandem-loading">Loading...</div>;
  }

  return (
    <div className="tandem-detail">
      <div className="tandem-detail-content">
        {/* TODO: AI should render detailed fields from ${typeShortName} */}
        {Object.entries(data as Record<string, unknown>).map(([key, value]) => (
          <div key={key} className="tandem-detail-field">
            <span className="tandem-detail-label">{key}:</span>
            <span className="tandem-detail-value">{String(value)}</span>
          </div>
        ))}
      </div>
      ${this.generateActionButtons(component.actions || [])}
    </div>
  );
}
`;
    return { filename: `components/${name}.tsx`, content };
  }

  private emitGenericComponent(
    name: string,
    component: IRComponent
  ): GeneratedCode {
    let content = `// Generated by Tandem - DO NOT EDIT

interface ${name}Props {
  // TODO: Define props for ${component.element} component
}

/**
 * ${component.spec || `${component.element} component`}
 */
export function ${name}(props: ${name}Props) {
  return (
    <div className="tandem-${component.element}">
      {/* TODO: Implement ${component.element} component */}
    </div>
  );
}
`;
    return { filename: `components/${name}.tsx`, content };
  }

  private generateActionButtons(
    actions: string[],
    dataVar: string = ""
  ): string {
    if (actions.length === 0) return "";

    const buttonParams = dataVar ? `"${shorten(actions[0])}", ${dataVar}` : `"${shorten(actions[0])}"`;

    return `<div className="tandem-actions">
        ${actions
          .map((a) => {
            const actionName = shorten(a);
            const params = dataVar ? `"${actionName}", ${dataVar}` : `"${actionName}"`;
            return `<button onClick={() => onAction?.(${params})}>${actionName}</button>`;
          })
          .join("\n        ")}
      </div>`;
  }

  private emitIndex(ir: TandemIR): GeneratedCode {
    const exports = Array.from(ir.components.keys())
      .map((fqn) => {
        const name = shorten(fqn);
        return `export { ${name} } from "./${name}";`;
      })
      .join("\n");

    return {
      filename: "components/index.ts",
      content: `// Generated by Tandem - DO NOT EDIT\n${exports}\n`,
    };
  }

  private getTypeShortName(typeRef?: IRTypeRef): string {
    if (!typeRef) return "Data";
    if (typeRef.kind === "simple") {
      return shorten(typeRef.fqn);
    }
    // For generic types like List<User>, return the inner type
    if (typeRef.kind === "generic" && typeRef.typeArgs.length > 0) {
      return this.getTypeShortName(typeRef.typeArgs[0]);
    }
    return "Data";
  }

  private extractListInnerType(typeRef?: IRTypeRef): string {
    if (!typeRef) return "unknown";
    if (typeRef.kind === "generic" && typeRef.name === "List") {
      return this.typeMapper.mapType(typeRef.typeArgs[0]);
    }
    // If it's not a List, return the mapped type
    return this.typeMapper.mapType(typeRef);
  }
}
