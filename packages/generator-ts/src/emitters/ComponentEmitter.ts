import { TandemIR, IRComponent, IRTypeRef } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { ITypeMapper } from "../interfaces/ITypeMapper";
import { shorten, toHookName } from "../utils/naming";
import {
  groupByModule,
  moduleToDirectory,
  getRelativeImportPath,
} from "../utils/modulePath";
import type {
  CodeGenerationPipeline,
  ComponentCode,
  PipelineProgressEvent,
} from "@tandem-lang/llm";

/**
 * Configuration for the component emitter.
 */
export interface ComponentEmitterConfig {
  /**
   * LLM pipeline for generating component implementations.
   */
  pipeline: CodeGenerationPipeline;

  /**
   * Callback for progress reporting.
   */
  onProgress?: (event: PipelineProgressEvent) => void;
}

/**
 * Emits React component files from Tandem IR components.
 * Generates semantic UI components based on element type.
 * Components are organized by module path.
 * Uses LLM to generate actual component implementations.
 */
export class ComponentEmitter implements ICodeEmitter {
  private readonly typeMapper: ITypeMapper;
  private readonly config: ComponentEmitterConfig;

  constructor(typeMapper: ITypeMapper, config: ComponentEmitterConfig) {
    this.typeMapper = typeMapper;
    this.config = config;
  }

  async emit(ir: TandemIR): Promise<GeneratedCode[]> {
    if (ir.components.size === 0) {
      return [];
    }

    return this.emitWithLLM(ir);
  }

  /**
   * Emit with LLM-powered implementations.
   */
  private async emitWithLLM(ir: TandemIR): Promise<GeneratedCode[]> {
    const files: GeneratedCode[] = [];

    // Group components by module
    const componentsByModule = groupByModule(ir.components);

    // Track exports for aggregate barrel
    const moduleExports: Map<string, string[]> = new Map();

    // Emit components for each module
    for (const [modulePath, components] of componentsByModule) {
      const moduleDir = this.getComponentDir(modulePath);
      const componentNames: string[] = [];

      for (const [fqn, component] of components) {
        const name = shorten(fqn);
        componentNames.push(name);

        const file = await this.emitComponentWithLLM(
          fqn,
          component,
          ir,
          modulePath,
        );
        file.filename = `components/${moduleDir}/${name}.tsx`;
        files.push(file);
      }

      // Generate per-module index
      files.push({
        filename: `components/${moduleDir}/index.ts`,
        content: this.emitModuleIndex(componentNames),
      });

      moduleExports.set(moduleDir, componentNames);
    }

    // Generate aggregate components/index.ts
    files.push({
      filename: "components/index.ts",
      content: this.emitAggregateIndex(moduleExports),
    });

    return files;
  }

  /**
   * Emit a single component with LLM-generated content.
   */
  private async emitComponentWithLLM(
    fqn: string,
    component: IRComponent,
    ir: TandemIR,
    modulePath: string,
  ): Promise<GeneratedCode> {
    const result = await this.config.pipeline.generateComponent(ir, fqn);

    if (result.success && result.code) {
      return this.buildComponentFile(fqn, component, result.code, modulePath);
    } else {
      throw new Error(`Failed to generate component ${fqn}: ${result.error || "Unknown error"}`);
    }
  }

  /**
   * Build component file from LLM-generated code.
   */
  private buildComponentFile(
    fqn: string,
    component: IRComponent,
    code: ComponentCode,
    modulePath: string,
  ): GeneratedCode {
    const name = shorten(fqn);
    const displayType = component.displays
      ? this.typeMapper.mapType(component.displays)
      : undefined;
    const typeShortName = this.getTypeShortName(component.displays);

    const hooksPath = this.getRelativeHooksPath(modulePath);
    const typesPath = this.getRelativeTypesPath(modulePath);

    let content = "// Generated by Tandem with AI-powered implementations\n";

    // Add imports
    const imports = new Set<string>();
    imports.add('import React from "react";');

    // Add React hooks imports
    if (code.hooks?.length) {
      const hookNames = this.extractReactHookNames(code.hooks);
      if (hookNames.length > 0) {
        imports.add(`import { ${hookNames.join(", ")} } from "react";`);
      }
    }

    // Add custom imports from LLM
    if (code.imports?.length) {
      for (const imp of code.imports) {
        imports.add(imp);
      }
    }

    // Add hook imports for bound intent or actions
    if (component.binds) {
      imports.add(
        `import { ${toHookName(component.binds)} } from "${hooksPath}/hooks";`,
      );
    }
    if (component.actions?.length) {
      for (const action of component.actions) {
        imports.add(
          `import { ${toHookName(action)} } from "${hooksPath}/hooks";`,
        );
      }
    }

    // Add type imports
    if (typeShortName && typeShortName !== "Data") {
      imports.add(
        `import type { ${typeShortName} } from "${typesPath}/types";`,
      );
    }

    content += Array.from(imports).join("\n") + "\n\n";

    // Add props interface
    content += this.generatePropsInterface(name, component, displayType);

    // Add component JSDoc
    if (component.spec) {
      content += `/**\n * ${component.spec}\n */\n`;
    }

    // Build the component function
    content += `export function ${name}(props: ${name}Props) {\n`;

    // Add hooks
    if (code.hooks?.length) {
      for (const hook of code.hooks) {
        content += `  ${hook}\n`;
      }
      content += "\n";
    }

    // Add handlers
    if (code.handlers?.length) {
      for (const handler of code.handlers) {
        content += `  ${handler.implementation}\n\n`;
      }
    }

    // Add return with JSX
    content += `  return (\n`;
    content += this.indentCode(code.jsx, 4);
    content += `\n  );\n`;
    content += `}\n`;

    // Add styles if present
    if (code.styles) {
      content += `\n// Styles\n${code.styles}\n`;
    }

    return {
      filename: `components/${name}.tsx`,
      content,
    };
  }

  /**
   * Generate props interface for a component.
   */
  private generatePropsInterface(
    name: string,
    component: IRComponent,
    displayType?: string,
  ): string {
    let content = `interface ${name}Props {\n`;

    if (displayType) {
      content += `  data: ${displayType};\n`;
    }

    if (component.element === "form") {
      content += `  onSuccess?: () => void;\n`;
      content += `  onError?: (error: Error) => void;\n`;
      content += `  initialData?: Partial<${displayType || "unknown"}>;\n`;
    } else if (component.element === "modal") {
      content += `  isOpen: boolean;\n`;
      content += `  onClose: () => void;\n`;
      content += `  onSuccess?: () => void;\n`;
    } else if (component.element === "list" || component.element === "table") {
      content += `  isLoading?: boolean;\n`;
    }

    if (component.actions?.length) {
      content += `  onAction?: (action: string, data?: unknown) => void;\n`;
    }

    content += `}\n\n`;
    return content;
  }

  /**
   * Extract React hook names from hook statements.
   */
  private extractReactHookNames(hooks: string[]): string[] {
    const reactHooks = [
      "useState",
      "useEffect",
      "useCallback",
      "useMemo",
      "useRef",
      "useContext",
      "useReducer",
    ];
    const found = new Set<string>();

    for (const hook of hooks) {
      for (const reactHook of reactHooks) {
        if (hook.includes(reactHook)) {
          found.add(reactHook);
        }
      }
    }

    return Array.from(found);
  }

  /**
   * Indent code by spaces.
   */
  private indentCode(code: string, spaces: number): string {
    const indent = " ".repeat(spaces);
    return code
      .split("\n")
      .map((line) => (line.trim() ? indent + line : line))
      .join("\n");
  }

  /**
   * Get the component directory name from a module path.
   */
  private getComponentDir(modulePath: string): string {
    const parts = modulePath.split(".");
    return parts[parts.length - 1];
  }

  /**
   * Get relative path from component to hooks/types based on module.
   */
  private getRelativeHooksPath(componentModulePath: string): string {
    const componentDir = `components/${this.getComponentDir(componentModulePath)}`;
    const hooksDir = moduleToDirectory(componentModulePath);
    return getRelativeImportPath(componentDir, hooksDir);
  }

  /**
   * Get relative path from component to types.
   */
  private getRelativeTypesPath(componentModulePath: string): string {
    const componentDir = `components/${this.getComponentDir(componentModulePath)}`;
    const typesDir = moduleToDirectory(componentModulePath);
    return getRelativeImportPath(componentDir, typesDir);
  }

  private emitModuleIndex(componentNames: string[]): string {
    const exports = componentNames
      .sort()
      .map((name) => `export { ${name} } from "./${name}";`)
      .join("\n");

    return `// Generated by Tandem - DO NOT EDIT\n${exports}\n`;
  }

  private emitAggregateIndex(moduleExports: Map<string, string[]>): string {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "// Aggregate component exports from all modules\n\n";

    const sortedModules = Array.from(moduleExports.keys()).sort();

    for (const moduleDir of sortedModules) {
      const names = moduleExports.get(moduleDir)!;
      if (names.length > 0) {
        const sortedNames = names.sort().join(", ");
        content += `export { ${sortedNames} } from "./${moduleDir}";\n`;
      }
    }

    return content;
  }

  private getTypeShortName(typeRef?: IRTypeRef): string {
    if (!typeRef) return "Data";
    if (typeRef.kind === "simple") {
      return shorten(typeRef.fqn);
    }
    // For generic types like List<User>, return the inner type
    if (typeRef.kind === "generic" && typeRef.typeArgs.length > 0) {
      return this.getTypeShortName(typeRef.typeArgs[0]);
    }
    return "Data";
  }

  private extractListInnerType(typeRef?: IRTypeRef): string {
    if (!typeRef) return "unknown";
    if (typeRef.kind === "generic" && typeRef.name === "List") {
      return this.typeMapper.mapType(typeRef.typeArgs[0]);
    }
    // If it's not a List, return the mapped type
    return this.typeMapper.mapType(typeRef);
  }
}
