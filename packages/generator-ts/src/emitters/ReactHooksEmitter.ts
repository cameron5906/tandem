import { TandemIR } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { shorten, toHookName, toApiMethodName } from "../utils/naming";
import { classifyIntent, isQueryIntent } from "../utils/intentClassifier";

/**
 * Emits React Query hooks from Tandem IR.
 */
export class ReactHooksEmitter implements ICodeEmitter {
  /**
   * Emit React Query hooks from the IR.
   */
  emit(ir: TandemIR): GeneratedCode[] {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from \"@tanstack/react-query\";\n";
    content += "import api from \"../api/client\";\n";
    content += "import {\n";

    // Import input/output types
    const typeImports: string[] = [];
    for (const [fqn] of ir.intents) {
      const name = shorten(fqn);
      typeImports.push(`${name}Input`);
      typeImports.push(`${name}Output`);
    }
    content += `  ${typeImports.join(",\n  ")}\n`;
    content += "} from \"../types\";\n\n";

    // Emit hooks for each intent
    for (const [fqn, intent] of ir.intents) {
      const isQuery = isQueryIntent(fqn);
      if (isQuery) {
        content += this.emitQueryHook(fqn, intent.spec);
      } else {
        content += this.emitMutationHook(fqn, intent.spec);
      }
    }

    return [{ filename: "hooks/index.ts", content }];
  }

  /**
   * Emit a useQuery hook for read operations.
   */
  private emitQueryHook(fqn: string, spec?: string): string {
    const name = shorten(fqn);
    const hookName = toHookName(fqn);
    const apiMethod = toApiMethodName(fqn);

    let content = "";

    // Add JSDoc comment if spec is available
    if (spec) {
      content += `/**\n * ${spec}\n */\n`;
    }

    content += `export function ${hookName}(\n`;
    content += `  input: ${name}Input,\n`;
    content += `  options?: Omit<UseQueryOptions<${name}Output, Error>, "queryKey" | "queryFn">\n`;
    content += `) {\n`;
    content += `  return useQuery({\n`;
    content += `    queryKey: ["${name}", input] as const,\n`;
    content += `    queryFn: () => api.${apiMethod}(input),\n`;
    content += `    ...options,\n`;
    content += `  });\n`;
    content += `}\n\n`;

    return content;
  }

  /**
   * Emit a useMutation hook for write operations.
   */
  private emitMutationHook(fqn: string, spec?: string): string {
    const name = shorten(fqn);
    const hookName = toHookName(fqn);
    const apiMethod = toApiMethodName(fqn);

    let content = "";

    // Add JSDoc comment if spec is available
    if (spec) {
      content += `/**\n * ${spec}\n */\n`;
    }

    content += `export function ${hookName}(\n`;
    content += `  options?: Omit<UseMutationOptions<${name}Output, Error, ${name}Input>, "mutationFn">\n`;
    content += `) {\n`;
    content += `  return useMutation({\n`;
    content += `    mutationFn: (input: ${name}Input) => api.${apiMethod}(input),\n`;
    content += `    ...options,\n`;
    content += `  });\n`;
    content += `}\n\n`;

    return content;
  }
}
