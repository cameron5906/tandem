import { TandemIR, IRIntent } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { shorten, toHookName, toApiMethodName } from "../utils/naming";
import { isQueryIntent } from "../utils/intentClassifier";
import { groupByModule, moduleToDirectory } from "../utils/modulePath";

/**
 * Emits React Query hooks from Tandem IR.
 * Generates per-module hook files organized by module path.
 */
export class ReactHooksEmitter implements ICodeEmitter {
  /**
   * Emit React Query hooks from the IR.
   * Generates per-module files organized by module path.
   */
  emit(ir: TandemIR): GeneratedCode[] {
    if (ir.intents.size === 0) {
      return [];
    }

    const files: GeneratedCode[] = [];

    // Group intents by module
    const intentsByModule = groupByModule(ir.intents);

    // Track module hook names for aggregate
    const moduleHookNames: Map<string, string[]> = new Map();

    // Emit hooks.ts for each module
    for (const [modulePath, intents] of intentsByModule) {
      const dir = moduleToDirectory(modulePath);
      const { content, hookNames } = this.emitModuleHooks(dir, intents);

      files.push({
        filename: `${dir}/hooks.ts`,
        content,
      });

      moduleHookNames.set(dir, hookNames);
    }

    // Generate aggregate hooks/index.ts that re-exports from all modules
    files.push({
      filename: "hooks/index.ts",
      content: this.emitAggregateHooks(moduleHookNames),
    });

    return files;
  }

  /**
   * Emit hooks.ts content for a single module.
   */
  private emitModuleHooks(
    modulePath: string,
    intents: Map<string, IRIntent>
  ): { content: string; hookNames: string[] } {
    const hookNames: string[] = [];

    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += 'import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from "@tanstack/react-query";\n';
    content += 'import { api } from "./client";\n';
    content += "import type {\n";

    // Import input/output types from local types.ts
    const typeImports: string[] = [];
    for (const [fqn] of intents) {
      const name = shorten(fqn);
      typeImports.push(`${name}Input`);
      typeImports.push(`${name}Output`);
    }
    content += `  ${typeImports.join(",\n  ")}\n`;
    content += '} from "./types";\n\n';

    // Emit hooks for each intent
    for (const [fqn, intent] of intents) {
      const hookName = toHookName(fqn);
      hookNames.push(hookName);

      const isQuery = isQueryIntent(fqn);
      if (isQuery) {
        content += this.emitQueryHook(fqn, intent.spec);
      } else {
        content += this.emitMutationHook(fqn, intent.spec);
      }
    }

    return { content, hookNames };
  }

  /**
   * Emit aggregate hooks that re-exports all module hooks.
   */
  private emitAggregateHooks(moduleHookNames: Map<string, string[]>): string {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "// Aggregate hooks re-exporting from all modules\n\n";

    // Sort modules for consistent output
    const sortedModules = Array.from(moduleHookNames.keys()).sort();

    // Re-export all hooks from each module
    for (const modulePath of sortedModules) {
      const hookNames = moduleHookNames.get(modulePath)!;
      if (hookNames.length > 0) {
        const sortedHooks = hookNames.sort().join(", ");
        content += `export { ${sortedHooks} } from "../${modulePath}/hooks";\n`;
      }
    }

    return content;
  }

  /**
   * Emit a useQuery hook for read operations.
   */
  private emitQueryHook(fqn: string, spec?: string): string {
    const name = shorten(fqn);
    const hookName = toHookName(fqn);
    const apiMethod = toApiMethodName(fqn);

    let content = "";

    // Add JSDoc comment if spec is available
    if (spec) {
      content += `/**\n * ${spec}\n */\n`;
    }

    content += `export function ${hookName}(\n`;
    content += `  input: ${name}Input,\n`;
    content += `  options?: Omit<UseQueryOptions<${name}Output, Error>, "queryKey" | "queryFn">\n`;
    content += `) {\n`;
    content += `  return useQuery({\n`;
    content += `    queryKey: ["${name}", input] as const,\n`;
    content += `    queryFn: () => api.${apiMethod}(input),\n`;
    content += `    ...options,\n`;
    content += `  });\n`;
    content += `}\n\n`;

    return content;
  }

  /**
   * Emit a useMutation hook for write operations.
   */
  private emitMutationHook(fqn: string, spec?: string): string {
    const name = shorten(fqn);
    const hookName = toHookName(fqn);
    const apiMethod = toApiMethodName(fqn);

    let content = "";

    // Add JSDoc comment if spec is available
    if (spec) {
      content += `/**\n * ${spec}\n */\n`;
    }

    content += `export function ${hookName}(\n`;
    content += `  options?: Omit<UseMutationOptions<${name}Output, Error, ${name}Input>, "mutationFn">\n`;
    content += `) {\n`;
    content += `  return useMutation({\n`;
    content += `    mutationFn: (input: ${name}Input) => api.${apiMethod}(input),\n`;
    content += `    ...options,\n`;
    content += `  });\n`;
    content += `}\n\n`;

    return content;
  }
}
