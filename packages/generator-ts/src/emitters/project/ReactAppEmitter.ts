import { GeneratedFile } from "@tandem-lang/generator-core";
import type { TandemIR } from "@tandem-lang/compiler";
import type { CodeGenerationPipeline, AppLayoutCode } from "@tandem-lang/llm";

/**
 * Configuration for React app generation.
 */
export interface ReactAppConfig {
  /** Application title */
  appTitle?: string;
  /** Tandem IR for component-aware generation */
  ir?: TandemIR;
  /** LLM pipeline for AI-powered layout generation */
  pipeline?: CodeGenerationPipeline;
}

/**
 * Emitter for generating React application entry point and App component.
 * Supports both static placeholder generation and LLM-powered layout generation.
 */
export class ReactAppEmitter {
  /**
   * Generate main.tsx and App.tsx files.
   * If IR and pipeline are provided, uses LLM to generate a component-aware App layout.
   */
  async emit(config: ReactAppConfig = {}): Promise<GeneratedFile[]> {
    const appTitle = config.appTitle ?? "Tandem App";

    const mainFile = this.generateMain();

    // If we have IR and pipeline with components, use LLM generation
    if (config.ir && config.pipeline && config.ir.components.size > 0) {
      const appFile = await this.generateAppWithLLM(
        appTitle,
        config.ir,
        config.pipeline,
      );
      return [mainFile, appFile];
    }

    // Fallback to static placeholder
    return [mainFile, this.generateStaticApp(appTitle)];
  }

  private generateMain(): GeneratedFile {
    const content = `import React from "react";
import ReactDOM from "react-dom/client";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import App from "./App";

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>
);
`;

    return {
      path: "src/main.tsx",
      content,
    };
  }

  /**
   * Generate App.tsx using LLM pipeline.
   */
  private async generateAppWithLLM(
    appTitle: string,
    ir: TandemIR,
    pipeline: CodeGenerationPipeline,
  ): Promise<GeneratedFile> {
    const result = await pipeline.generateAppLayout(ir, appTitle);

    if (!result.success || !result.code) {
      // Fallback to static if LLM fails
      console.warn(
        `App layout generation failed: ${result.error}. Using fallback.`,
      );
      return this.generateStaticApp(appTitle);
    }

    return this.buildAppFile(appTitle, ir, result.code);
  }

  /**
   * Build App.tsx file from LLM-generated code.
   * Handles all imports separately since LLM only generates function body.
   */
  private buildAppFile(
    appTitle: string,
    ir: TandemIR,
    code: AppLayoutCode,
  ): GeneratedFile {
    let content = "// Generated by Tandem with AI-powered layout\n";

    // Build imports
    const imports = new Set<string>();
    imports.add('import React from "react";');

    // Add React hooks imports based on what LLM used
    const hookNames = this.extractReactHookNames(
      code.hooks ?? [],
      code.stateDeclarations ?? [],
    );
    if (hookNames.length > 0) {
      imports.add(`import { ${hookNames.join(", ")} } from "react";`);
    }

    // Import all components from barrel
    const componentNames = this.getComponentNames(ir);
    if (componentNames.length > 0) {
      imports.add(
        `import { ${componentNames.join(", ")} } from "./components";`,
      );
    }

    content += Array.from(imports).join("\n") + "\n\n";

    // Build component function
    content += `function App() {\n`;

    // Add state declarations
    if (code.stateDeclarations?.length) {
      for (const decl of code.stateDeclarations) {
        content += `  ${decl}\n`;
      }
      content += "\n";
    }

    // Add hooks
    if (code.hooks?.length) {
      for (const hook of code.hooks) {
        content += `  ${hook}\n`;
      }
      content += "\n";
    }

    // Add handlers
    if (code.handlers?.length) {
      for (const handler of code.handlers) {
        content += `  ${handler.implementation}\n\n`;
      }
    }

    // Add return with JSX
    content += `  return (\n`;
    content += this.indentCode(code.jsx, 4);
    content += `\n  );\n`;
    content += `}\n\n`;
    content += `export default App;\n`;

    return {
      path: "src/App.tsx",
      content,
    };
  }

  /**
   * Generate static placeholder App.tsx.
   */
  private generateStaticApp(appTitle: string): GeneratedFile {
    const content = `function App() {
  return (
    <div>
      <h1>${appTitle}</h1>
      {/* Your components here */}
    </div>
  );
}

export default App;
`;

    return {
      path: "src/App.tsx",
      content,
    };
  }

  /**
   * Get all component names from IR.
   */
  private getComponentNames(ir: TandemIR): string[] {
    const names: string[] = [];
    for (const [fqn] of ir.components) {
      const parts = fqn.split(".");
      names.push(parts[parts.length - 1]);
    }
    return names.sort();
  }

  /**
   * Extract React hook names from generated code.
   */
  private extractReactHookNames(
    hooks: string[],
    stateDecls: string[],
  ): string[] {
    const reactHooks = [
      "useState",
      "useEffect",
      "useCallback",
      "useMemo",
      "useRef",
      "useContext",
      "useReducer",
    ];
    const found = new Set<string>();

    const allCode = [...hooks, ...stateDecls].join("\n");
    for (const hookName of reactHooks) {
      if (allCode.includes(hookName)) {
        found.add(hookName);
      }
    }

    return Array.from(found);
  }

  /**
   * Indent code by spaces.
   */
  private indentCode(code: string, spaces: number): string {
    const indent = " ".repeat(spaces);
    return code
      .split("\n")
      .map((line) => (line.trim() ? indent + line : line))
      .join("\n");
  }
}
