import { TandemIR } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { shorten, toApiMethodName, toRoutePath } from "../utils/naming";
import { classifyIntent } from "../utils/intentClassifier";

/**
 * Options for the API client emitter.
 */
export interface ApiClientEmitterOptions {
  /** Base URL for API requests (default: "/api") */
  baseUrl?: string;
}

/**
 * Emits a typed fetch-based API client from Tandem IR.
 */
export class ApiClientEmitter implements ICodeEmitter {
  private options: Required<ApiClientEmitterOptions>;

  constructor(options: ApiClientEmitterOptions = {}) {
    this.options = {
      baseUrl: options.baseUrl ?? "/api",
    };
  }

  /**
   * Emit the API client from the IR.
   */
  emit(ir: TandemIR): GeneratedCode[] {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "import {\n";

    // Import input/output types
    const typeImports: string[] = [];
    for (const [fqn] of ir.intents) {
      const name = shorten(fqn);
      typeImports.push(`${name}Input`);
      typeImports.push(`${name}Output`);
    }
    content += `  ${typeImports.join(",\n  ")}\n`;
    content += "} from \"../types\";\n\n";

    // Helper for making requests
    content += this.emitHelpers();

    // API client object
    content += "export const api = {\n";

    for (const [fqn, intent] of ir.intents) {
      content += this.emitApiMethod(fqn, intent.spec);
    }

    content += "};\n\n";
    content += "export default api;\n";

    return [{ filename: "api/client.ts", content }];
  }

  /**
   * Emit helper functions for the API client.
   */
  private emitHelpers(): string {
    return `const BASE_URL = "${this.options.baseUrl}";

interface RequestOptions {
  method: string;
  headers?: Record<string, string>;
  body?: string;
}

async function request<T>(path: string, options: RequestOptions): Promise<T> {
  const response = await fetch(\`\${BASE_URL}\${path}\`, {
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });

  if (!response.ok) {
    throw new Error(\`API error: \${response.status} \${response.statusText}\`);
  }

  return response.json();
}

function toQueryString(params: Record<string, unknown>): string {
  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    if (value !== undefined && value !== null) {
      searchParams.append(key, String(value));
    }
  }
  const queryString = searchParams.toString();
  return queryString ? \`?\${queryString}\` : "";
}

`;
  }

  /**
   * Emit a single API method.
   */
  private emitApiMethod(fqn: string, spec?: string): string {
    const name = shorten(fqn);
    const methodName = toApiMethodName(fqn);
    const routePath = toRoutePath(fqn);
    const { method } = classifyIntent(fqn);

    let content = "";

    // Add JSDoc comment if spec is available
    if (spec) {
      content += `  /** ${spec} */\n`;
    }

    content += `  ${methodName}: async (input: ${name}Input): Promise<${name}Output> => {\n`;

    if (method === "GET" || method === "DELETE") {
      // Send input as query parameters
      content += `    return request<${name}Output>(\n`;
      content += `      \`${routePath}\${toQueryString(input as Record<string, unknown>)}\`,\n`;
      content += `      { method: "${method}" }\n`;
      content += `    );\n`;
    } else {
      // Send input as JSON body
      content += `    return request<${name}Output>("${routePath}", {\n`;
      content += `      method: "${method}",\n`;
      content += `      body: JSON.stringify(input),\n`;
      content += `    });\n`;
    }

    content += `  },\n\n`;

    return content;
  }
}
