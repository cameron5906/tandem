import { TandemIR, IRIntent } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { shorten, toApiMethodName, toRoutePath } from "../utils/naming";
import { classifyIntent } from "../utils/intentClassifier";
import { groupByModule, moduleToDirectory } from "../utils/modulePath";

/**
 * Options for the API client emitter.
 */
export interface ApiClientEmitterOptions {
  /** Base URL for API requests (default: "/api") */
  baseUrl?: string;
}

/**
 * Emits a typed fetch-based API client from Tandem IR.
 * Generates per-module client files organized by module path.
 */
export class ApiClientEmitter implements ICodeEmitter {
  private options: Required<ApiClientEmitterOptions>;

  constructor(options: ApiClientEmitterOptions = {}) {
    this.options = {
      baseUrl: options.baseUrl ?? "/api",
    };
  }

  /**
   * Emit the API client from the IR.
   * Generates per-module files organized by module path.
   */
  emit(ir: TandemIR): GeneratedCode[] {
    if (ir.intents.size === 0) {
      return [];
    }

    const files: GeneratedCode[] = [];

    // Group intents by module
    const intentsByModule = groupByModule(ir.intents);

    // Track module exports for aggregate
    const moduleApiNames: Map<string, string[]> = new Map();

    // Emit client.ts for each module
    for (const [modulePath, intents] of intentsByModule) {
      const dir = moduleToDirectory(modulePath);
      const { content, methodNames } = this.emitModuleClient(dir, intents);

      files.push({
        filename: `${dir}/client.ts`,
        content,
      });

      moduleApiNames.set(dir, methodNames);
    }

    // Generate aggregate api/client.ts that re-exports from all modules
    files.push({
      filename: "api/client.ts",
      content: this.emitAggregateClient(moduleApiNames),
    });

    return files;
  }

  /**
   * Emit client.ts content for a single module.
   */
  private emitModuleClient(
    modulePath: string,
    intents: Map<string, IRIntent>
  ): { content: string; methodNames: string[] } {
    const methodNames: string[] = [];

    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "import type {\n";

    // Import input/output types from local types.ts
    const typeImports: string[] = [];
    for (const [fqn] of intents) {
      const name = shorten(fqn);
      typeImports.push(`${name}Input`);
      typeImports.push(`${name}Output`);
    }
    content += `  ${typeImports.join(",\n  ")}\n`;
    content += '} from "./types";\n\n';

    // Helper for making requests
    content += this.emitHelpers();

    // API client object
    content += "export const api = {\n";

    for (const [fqn, intent] of intents) {
      const methodName = toApiMethodName(fqn);
      methodNames.push(methodName);
      content += this.emitApiMethod(fqn, intent.spec);
    }

    content += "};\n\n";
    content += "export default api;\n";

    return { content, methodNames };
  }

  /**
   * Emit aggregate client that re-exports all module clients.
   */
  private emitAggregateClient(moduleApiNames: Map<string, string[]>): string {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "// Aggregate API client re-exporting from all modules\n\n";

    // Sort modules for consistent output
    const sortedModules = Array.from(moduleApiNames.keys()).sort();

    // Import api from each module with alias
    for (const modulePath of sortedModules) {
      const alias = this.getModuleAlias(modulePath);
      content += `import { api as ${alias}Api } from "../${modulePath}/client";\n`;
    }

    content += "\n";

    // Create combined api object
    content += "export const api = {\n";

    for (const modulePath of sortedModules) {
      const alias = this.getModuleAlias(modulePath);
      content += `  ...${alias}Api,\n`;
    }

    content += "};\n\n";
    content += "export default api;\n";

    return content;
  }

  /**
   * Get a safe alias name from a module path.
   */
  private getModuleAlias(modulePath: string): string {
    // Convert "api/users" to "apiUsers"
    return modulePath
      .split("/")
      .map((part, index) =>
        index === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)
      )
      .join("");
  }

  /**
   * Emit helper functions for the API client.
   */
  private emitHelpers(): string {
    return `const BASE_URL = "${this.options.baseUrl}";

interface RequestOptions {
  method: string;
  headers?: Record<string, string>;
  body?: string;
}

async function request<T>(path: string, options: RequestOptions): Promise<T> {
  const response = await fetch(\`\${BASE_URL}\${path}\`, {
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });

  if (!response.ok) {
    throw new Error(\`API error: \${response.status} \${response.statusText}\`);
  }

  return response.json();
}

function toQueryString(params: Record<string, unknown>): string {
  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    if (value !== undefined && value !== null) {
      searchParams.append(key, String(value));
    }
  }
  const queryString = searchParams.toString();
  return queryString ? \`?\${queryString}\` : "";
}

`;
  }

  /**
   * Emit a single API method.
   */
  private emitApiMethod(fqn: string, spec?: string): string {
    const name = shorten(fqn);
    const methodName = toApiMethodName(fqn);
    const routePath = toRoutePath(fqn);
    const { method } = classifyIntent(fqn);

    let content = "";

    // Add JSDoc comment if spec is available
    if (spec) {
      content += `  /** ${spec} */\n`;
    }

    content += `  ${methodName}: async (input: ${name}Input): Promise<${name}Output> => {\n`;

    if (method === "GET" || method === "DELETE") {
      // Send input as query parameters
      content += `    return request<${name}Output>(\n`;
      content += `      \`${routePath}\${toQueryString(input as unknown as Record<string, unknown>)}\`,\n`;
      content += `      { method: "${method}" }\n`;
      content += `    );\n`;
    } else {
      // Send input as JSON body
      content += `    return request<${name}Output>("${routePath}", {\n`;
      content += `      method: "${method}",\n`;
      content += `      body: JSON.stringify(input),\n`;
      content += `    });\n`;
    }

    content += `  },\n\n`;

    return content;
  }
}
