import { TandemIR, IRIntent } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import {
  shorten,
  toHandlerName,
  toRoutePath,
} from "../utils/naming";
import {
  classifyIntent,
  HttpMethod,
} from "../utils/intentClassifier";

/**
 * Emits Express.js route handlers and router setup from Tandem IR.
 */
export class ExpressRouteEmitter implements ICodeEmitter {
  /**
   * Emit Express route handlers and router from the IR.
   */
  emit(ir: TandemIR): GeneratedCode[] {
    const handlersContent = this.emitHandlers(ir);
    const routerContent = this.emitRouter(ir);

    return [
      { filename: "routes/handlers.ts", content: handlersContent },
      { filename: "routes/index.ts", content: routerContent },
    ];
  }

  /**
   * Emit handler stubs for all intents.
   */
  private emitHandlers(ir: TandemIR): string {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "import { RequestHandler } from \"express\";\n";
    content += "import {\n";

    // Import input/output types
    const typeImports: string[] = [];
    for (const [fqn] of ir.intents) {
      const name = shorten(fqn);
      typeImports.push(`${name}Input`);
      typeImports.push(`${name}Output`);
    }
    content += `  ${typeImports.join(",\n  ")}\n`;
    content += "} from \"../types\";\n\n";

    // Emit handler for each intent
    for (const [fqn, intent] of ir.intents) {
      content += this.emitHandler(fqn, intent);
    }

    return content;
  }

  /**
   * Emit a single handler stub.
   */
  private emitHandler(fqn: string, intent: IRIntent): string {
    const name = shorten(fqn);
    const handlerName = toHandlerName(fqn);
    const { method } = classifyIntent(fqn);

    // Determine where to get input from based on HTTP method
    const inputSource = method === "GET" || method === "DELETE" ? "req.query" : "req.body";

    let content = "";

    // Add JSDoc comment with spec if available
    if (intent.spec) {
      content += `/**\n * ${intent.spec}\n */\n`;
    }

    content += `export const ${handlerName}: RequestHandler<\n`;
    content += `  unknown,\n`;
    content += `  ${name}Output,\n`;
    content += `  ${name}Input\n`;
    content += `> = async (req, res) => {\n`;
    content += `  const input: ${name}Input = ${inputSource} as ${name}Input;\n`;
    content += `\n`;
    content += `  // TODO: Implement ${name} logic\n`;
    content += `  throw new Error("Not implemented: ${name}");\n`;
    content += `};\n\n`;

    return content;
  }

  /**
   * Emit the Express router setup.
   */
  private emitRouter(ir: TandemIR): string {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "import { Router } from \"express\";\n";
    content += "import {\n";

    // Import all handlers
    const handlerImports: string[] = [];
    for (const [fqn] of ir.intents) {
      handlerImports.push(toHandlerName(fqn));
    }
    content += `  ${handlerImports.join(",\n  ")}\n`;
    content += "} from \"./handlers\";\n\n";

    content += "export const router = Router();\n\n";

    // Register routes
    for (const [fqn] of ir.intents) {
      const handlerName = toHandlerName(fqn);
      const routePath = toRoutePath(fqn);
      const { method } = classifyIntent(fqn);

      content += `router.${this.methodToRouterMethod(method)}("${routePath}", ${handlerName});\n`;
    }

    content += "\nexport default router;\n";

    return content;
  }

  /**
   * Convert HTTP method to Express router method name.
   */
  private methodToRouterMethod(method: HttpMethod): string {
    return method.toLowerCase();
  }
}
