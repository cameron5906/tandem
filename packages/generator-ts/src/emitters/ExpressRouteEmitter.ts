import { TandemIR, IRIntent } from "@tandem-lang/compiler";
import { ICodeEmitter, GeneratedCode } from "../interfaces/ICodeEmitter";
import { shorten, toHandlerName, toRoutePath } from "../utils/naming";
import { classifyIntent, HttpMethod } from "../utils/intentClassifier";
import { groupByModule, moduleToDirectory } from "../utils/modulePath";
import type {
  CodeGenerationPipeline,
  HandlerCode,
  GenerationResult,
  PipelineProgressEvent,
} from "@tandem-lang/llm";

/**
 * Configuration for the Express route emitter.
 */
export interface ExpressRouteEmitterConfig {
  /**
   * LLM pipeline for generating handler implementations.
   */
  pipeline: CodeGenerationPipeline;

  /**
   * Callback for progress reporting.
   */
  onProgress?: (event: PipelineProgressEvent) => void;
}

/**
 * Emits Express.js route handlers and router setup from Tandem IR.
 * Generates per-module files organized by module path.
 * Uses LLM to generate actual handler implementations.
 */
export class ExpressRouteEmitter implements ICodeEmitter {
  private readonly config: ExpressRouteEmitterConfig;

  constructor(config: ExpressRouteEmitterConfig) {
    this.config = config;
  }

  /**
   * Emit Express route handlers and router from the IR.
   * Generates per-module files organized by module path.
   */
  async emit(ir: TandemIR): Promise<GeneratedCode[]> {
    if (ir.intents.size === 0) {
      return [];
    }

    return this.emitWithLLM(ir);
  }

  /**
   * Emit with LLM-powered implementations.
   */
  private async emitWithLLM(ir: TandemIR): Promise<GeneratedCode[]> {
    const files: GeneratedCode[] = [];

    // Group intents by module
    const intentsByModule = groupByModule(ir.intents);

    // Track module info for aggregate router
    const moduleRouterInfo: Map<string, { handlerNames: string[] }> = new Map();

    // Emit handlers.ts and routes.ts for each module
    for (const [modulePath, intents] of intentsByModule) {
      const dir = moduleToDirectory(modulePath);

      // Emit handlers with LLM
      const { content: handlersContent, handlerNames } =
        await this.emitModuleHandlersWithLLM(intents, ir);
      files.push({
        filename: `${dir}/handlers.ts`,
        content: handlersContent,
      });

      // Emit module router
      const routesContent = this.emitModuleRouter(intents);
      files.push({
        filename: `${dir}/routes.ts`,
        content: routesContent,
      });

      moduleRouterInfo.set(dir, { handlerNames });
    }

    // Generate aggregate routes/index.ts
    files.push({
      filename: "routes/index.ts",
      content: this.emitAggregateRouter(moduleRouterInfo),
    });

    return files;
  }

  /**
   * Emit handlers with LLM-generated implementations.
   */
  private async emitModuleHandlersWithLLM(
    intents: Map<string, IRIntent>,
    ir: TandemIR,
  ): Promise<{ content: string; handlerNames: string[] }> {
    const handlerNames: string[] = [];
    const generatedHandlers: Map<string, GenerationResult<HandlerCode>> =
      new Map();

    // Generate all handlers in parallel
    const generationPromises: Promise<void>[] = [];

    for (const [fqn] of intents) {
      const promise = this.config
        .pipeline!.generateHandler(ir, fqn)
        .then((result) => {
          generatedHandlers.set(fqn, result);
        });
      generationPromises.push(promise);
    }

    await Promise.all(generationPromises);

    // Build the handlers file content
    let content = "// Generated by Tandem with AI-powered implementations\n";
    content += 'import { RequestHandler } from "express";\n';
    content += "import type {\n";

    // Import input/output types from local types.ts
    const typeImports: string[] = [];
    for (const [fqn] of intents) {
      const name = shorten(fqn);
      typeImports.push(`${name}Input`);
      typeImports.push(`${name}Output`);
    }
    content += `  ${typeImports.join(",\n  ")}\n`;
    content += '} from "./types";\n\n';

    // Collect additional imports from generated code
    const additionalImports = new Set<string>();
    for (const result of generatedHandlers.values()) {
      if (result.success && result.code?.imports) {
        for (const imp of result.code.imports) {
          additionalImports.add(imp);
        }
      }
    }
    if (additionalImports.size > 0) {
      content += Array.from(additionalImports).join("\n") + "\n\n";
    }

    // Emit each handler
    for (const [fqn, intent] of intents) {
      const handlerName = toHandlerName(fqn);
      handlerNames.push(handlerName);

      const result = generatedHandlers.get(fqn);
      if (result?.success && result.code) {
        content += this.emitHandlerWithImplementation(fqn, intent, result.code);
      } else {
        throw new Error(`Failed to generate handler for ${fqn}: ${result?.error || "Unknown error"}`);
      }
    }

    return { content, handlerNames };
  }

  /**
   * Emit a handler with LLM-generated implementation.
   */
  private emitHandlerWithImplementation(
    fqn: string,
    intent: IRIntent,
    code: HandlerCode,
  ): string {
    const name = shorten(fqn);
    const handlerName = toHandlerName(fqn);
    const { method } = classifyIntent(fqn);

    const inputSource =
      method === "GET" || method === "DELETE" ? "req.query" : "req.body";

    let content = "";

    // Add JSDoc comment with spec if available
    if (intent.spec) {
      content += `/**\n * ${intent.spec}\n */\n`;
    }

    content += `export const ${handlerName}: RequestHandler<\n`;
    content += `  unknown,\n`;
    content += `  ${name}Output,\n`;
    content += `  ${name}Input\n`;
    content += `> = async (req, res) => {\n`;
    content += `  const input: ${name}Input = ${inputSource} as ${name}Input;\n`;
    content += `\n`;

    // Add validation if present
    if (code.validation) {
      content += `  // Input validation\n`;
      content += this.indentCode(code.validation, 2);
      content += `\n`;
    }

    // Add implementation
    content += this.indentCode(code.implementation, 2);
    content += `\n`;

    content += `};\n\n`;

    return content;
  }

  /**
   * Indent code by a number of spaces.
   */
  private indentCode(code: string, spaces: number): string {
    const indent = " ".repeat(spaces);
    return code
      .split("\n")
      .map((line) => (line.trim() ? indent + line : line))
      .join("\n");
  }

  /**
   * Emit router setup for a single module.
   */
  private emitModuleRouter(intents: Map<string, IRIntent>): string {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += 'import { Router } from "express";\n';
    content += "import {\n";

    // Import all handlers from local handlers.ts
    const handlerImports: string[] = [];
    for (const [fqn] of intents) {
      handlerImports.push(toHandlerName(fqn));
    }
    content += `  ${handlerImports.join(",\n  ")}\n`;
    content += '} from "./handlers";\n\n';

    content += "export const router = Router();\n\n";

    // Register routes
    for (const [fqn] of intents) {
      const handlerName = toHandlerName(fqn);
      const routePath = toRoutePath(fqn);
      const { method } = classifyIntent(fqn);

      content += `router.${this.methodToRouterMethod(method)}("${routePath}", ${handlerName});\n`;
    }

    content += "\nexport default router;\n";

    return content;
  }

  /**
   * Emit aggregate router that imports and uses all module routers.
   */
  private emitAggregateRouter(
    moduleRouterInfo: Map<string, { handlerNames: string[] }>,
  ): string {
    let content = "// Generated by Tandem - DO NOT EDIT\n";
    content += "// Aggregate router combining all module routers\n\n";
    content += 'import { Router } from "express";\n';

    // Sort modules for consistent output
    const sortedModules = Array.from(moduleRouterInfo.keys()).sort();

    // Import router from each module with alias
    for (const modulePath of sortedModules) {
      const alias = this.getModuleAlias(modulePath);
      content += `import { router as ${alias}Router } from "../${modulePath}/routes";\n`;
    }

    content += "\nexport const router = Router();\n\n";

    // Mount each module's router with a base path derived from module name
    for (const modulePath of sortedModules) {
      const alias = this.getModuleAlias(modulePath);
      // Use the last part of the module path as the mount point
      const mountPath = this.getMountPath(modulePath);
      content += `router.use("${mountPath}", ${alias}Router);\n`;
    }

    content += "\nexport default router;\n";

    return content;
  }

  /**
   * Get a safe alias name from a module path.
   */
  private getModuleAlias(modulePath: string): string {
    // Convert "api/users" to "apiUsers"
    return modulePath
      .split("/")
      .map((part, index) =>
        index === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1),
      )
      .join("");
  }

  /**
   * Get the mount path for a module router.
   */
  private getMountPath(modulePath: string): string {
    // Use the module path as the mount path: "api/users" -> "/api/users"
    return "/" + modulePath;
  }

  /**
   * Convert HTTP method to Express router method name.
   */
  private methodToRouterMethod(method: HttpMethod): string {
    return method.toLowerCase();
  }
}
