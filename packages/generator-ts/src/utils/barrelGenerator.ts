/**
 * Barrel file (index.ts) generator for module exports.
 */

/**
 * Represents an export to include in a barrel file.
 */
export interface BarrelExport {
  /** Export name or "*" for re-export all */
  name: string;
  /** Relative path to import from */
  from: string;
  /** Whether this is a type-only export */
  isType?: boolean;
  /** Use "export { name as alias }" syntax */
  alias?: string;
}

/**
 * Generate barrel file (index.ts) content with re-exports.
 * @param exports - Array of exports to include
 * @returns Generated TypeScript code
 */
export function generateBarrel(exports: BarrelExport[]): string {
  if (exports.length === 0) {
    return "// Generated by Tandem - DO NOT EDIT\n\nexport {};\n";
  }

  let content = "// Generated by Tandem - DO NOT EDIT\n\n";

  for (const exp of exports) {
    content += generateExportStatement(exp);
  }

  return content;
}

/**
 * Generate a single export statement.
 * @param exp - Export definition
 * @returns Export statement code
 */
function generateExportStatement(exp: BarrelExport): string {
  const typeKeyword = exp.isType ? "type " : "";

  if (exp.name === "*") {
    // Re-export all: export * from "./path"
    return `export ${typeKeyword}* from "${exp.from}";\n`;
  }

  if (exp.alias) {
    // Named re-export with alias: export { Name as Alias } from "./path"
    return `export ${typeKeyword}{ ${exp.name} as ${exp.alias} } from "${exp.from}";\n`;
  }

  // Named re-export: export { Name } from "./path"
  return `export ${typeKeyword}{ ${exp.name} } from "${exp.from}";\n`;
}

/**
 * Generate a barrel file that re-exports from multiple subdirectories.
 * @param subdirs - Array of subdirectory names to re-export from
 * @param isTypeOnly - Whether to use type-only exports
 * @returns Generated TypeScript code
 */
export function generateDirectoryBarrel(
  subdirs: string[],
  isTypeOnly: boolean = false
): string {
  const exports: BarrelExport[] = subdirs.map((dir) => ({
    name: "*",
    from: `./${dir}`,
    isType: isTypeOnly,
  }));

  return generateBarrel(exports);
}

/**
 * Generate a barrel file for a module with specific file exports.
 * @param files - Map of export name to relative path
 * @param isTypeOnly - Whether to use type-only exports
 * @returns Generated TypeScript code
 */
export function generateModuleBarrel(
  files: Map<string, string>,
  isTypeOnly: boolean = false
): string {
  const exports: BarrelExport[] = [];

  for (const [name, path] of files) {
    exports.push({
      name,
      from: path,
      isType: isTypeOnly,
    });
  }

  return generateBarrel(exports);
}

/**
 * Generate an aggregate barrel that re-exports all items from module directories.
 * Used for root-level files like src/types.ts that re-export from all modules.
 * @param moduleExports - Map of module path to list of export names
 * @param isTypeOnly - Whether to use type-only exports
 * @returns Generated TypeScript code
 */
export function generateAggregateBarrel(
  moduleExports: Map<string, string[]>,
  isTypeOnly: boolean = false
): string {
  let content = "// Generated by Tandem - DO NOT EDIT\n";
  content += "// Aggregate re-exports from all modules\n\n";

  // Sort module paths for consistent output
  const sortedModules = Array.from(moduleExports.keys()).sort();

  for (const modulePath of sortedModules) {
    const names = moduleExports.get(modulePath)!;
    const typeKeyword = isTypeOnly ? "type " : "";

    if (names.length > 0) {
      const exportList = names.sort().join(", ");
      content += `export ${typeKeyword}{ ${exportList} } from "./${modulePath}";\n`;
    }
  }

  return content;
}
